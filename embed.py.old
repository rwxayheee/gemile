def embed_by_pattern(mol: Chem.Mol, leaving_smarts_loc: dict[str, set[str]], 
                     alsoHs = True, target_smarts = "[O][PX4](=O)([O])[OX2][CX4][CX4]1[OX2][CX4][CX4][CX4]1[OX2][H]") -> Chem.Mol:
    
    tmol = Chem.MolFromSmarts(target_smarts)
    match_target = mol.GetSubstructMatches(tmol)
    if not match_target:
        logging.warning("Molecule doesn't contain target_smarts, embed_by_pattern returning original molecule")
        return mol
    if len(match_target) > 1:
        logging.warning("Molecule contain multiple copies of target_smarts, embed_by_pattern returning original molecule")
        return mol
    match_target = match_target[0]
    
    leaving_atoms = set()
    for leaving_smarts in leaving_smarts_loc: 
        lmol = Chem.MolFromSmarts(leaving_smarts)
        match_leaving = mol.GetSubstructMatches(lmol)

        if not match_leaving:
            logging.warning(f"Molecule doesn't contain leaving_smarts: {leaving_smarts}, skipping")
            continue
        if len(match_leaving[0]) <= max(leaving_smarts_loc[leaving_smarts]):
            logging.warning("match copies in match_leaving won't contain the required leaving_smarts_loc, skipping")
            continue

        for match_copy in match_leaving:
            match_in_copy = [idx for idx in match_copy if match_copy.index(idx) in leaving_smarts_loc[leaving_smarts]]
            match_leaving_atoms = set([mol.GetAtomWithIdx(idx) for idx in match_in_copy if idx in match_target])
            if match_leaving_atoms: 
                leaving_atoms.update(match_leaving_atoms)

    for atom in leaving_atoms:
        print(atom.GetProp("atom_id"))

    if not leaving_atoms:
        logging.warning("Molecule doesn't contain matching atoms for leaving_smarts_loc, embed_by_pattern returning original molecule")
        return mol
    
    if alsoHs:
        leaving_Hs = [ne for atom in leaving_atoms if atom.GetAtomicNum() > 1 for ne in atom.GetNeighbors() if ne.GetAtomicNum() == 1]
        leaving_atoms.update(leaving_Hs)
    
    return remove_atom_from_mol(mol, leaving_atoms)


def extend(mol: Chem.Mol, recipe: dict[str, tuple[str, str]]) -> Chem.Mol:
    """Add single atom to single atom by a single bond based a given build recipe."""
   
    if not recipe: 
        return mol
    
    rwmol = Chem.RWMol(mol)
    for build in recipe:
        new_atom_name, new_element = recipe[build]
        open_atoms = [atom for atom in mol.GetAtoms() if atom.GetProp('atom_id') in build]

        for open_atom in open_atoms: 
            print(f"building new atom {new_atom_name} ({new_element}) at {build}...")
            new_atom = Chem.Atom(new_element)
            new_atom.SetProp('atom_id', new_atom_name)
            new_idx = rwmol.AddAtom(new_atom)
            rwmol.AddBond(open_atom.GetIdx(), new_idx, Chem.BondType.SINGLE)

    rwmol.UpdatePropertyCache()
    return rwmol.GetMol()